
%%% Preamble
\documentclass{article}   					% KOMA-article class

\usepackage{lipsum}													% Package to create dummy text

\usepackage[english]{babel}								% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}				% Better typography
\usepackage{amsmath,amsfonts,amsthm}						% Math packages
\usepackage[pdftex]{graphicx}								% Enable pdflatex
\usepackage[svgnames]{xcolor}								% Enabling colors by their 'svgnames'
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}		% Custom captions under/above floats
\usepackage{epstopdf}									% Converts .eps to .pdf
\usepackage{subfig}									% Subfigures
\usepackage{booktabs}									% Nicer tables
\usepackage{fix-cm}									% Custom fontsizes
\usepackage{wrapfig}
\usepackage[margin=0.5in]{geometry}
\usepackage[pdftex,bookmarks=true]{hyperref}   %Bookmarks
\usepackage{longtable}

%%% Custom sectioning (sectsty package)
\usepackage{sectsty}									% Custom sectioning (see below)
\allsectionsfont{%										% Change font of al section commands
	\usefont{OT1}{phv}{b}{n}%							% bch-b-n: CharterBT-Bold font
	}

\sectionfont{%										% Change font of \section command
	\usefont{OT1}{phv}{b}{n}%							% bch-b-n: CharterBT-Bold font
	}



%%% Headers and footers
\usepackage{fancyhdr}									% Needed to define custom headers/footers
	\pagestyle{fancy}									% Enabling the custom headers/footers
\usepackage{lastpage}	

% Header (empty)
\lhead{}
\chead{}
\rhead{}
% Footer (you may change this to your own needs)
\lfoot{\footnotesize \texttt{Mu Sigma Innovation and Development} \textbullet ~http://mu-sigma.com/dothemath/innovation.html}
\cfoot{}
\rfoot{\footnotesize page \thepage\ of \pageref{LastPage}}	% "Page 1 of 2"
\renewcommand{\headrulewidth}{0.0pt}
\renewcommand{\footrulewidth}{0.4pt}



%%% Creating an initial of the very first character of the content
\usepackage{lettrine}
\newcommand{\initial}[1]{%
     \lettrine[lines=3,lhang=0.3,nindent=0em]{
     				\color{DarkGoldenrod}
     				{\textsf{#1}}}{}}



%%% Title, author and date metadata
\usepackage{titling}															% For custom titles

\newcommand{\HorRule}{\color{DarkGoldenrod}%			% Creating a horizontal rule
									  	\rule{\linewidth}{1pt}%
										}

%\begin{center}
\pretitle{\vspace{-30pt} \begin{flushleft} \HorRule 
				\fontsize{30}{30} \usefont{OT1}{phv}{b}{n} \color{DarkRed} \selectfont 
				}
\title{Benchmarking of Different Programming Languages }					% Title of your article goes here
\posttitle{\par\end{flushleft}\vskip 0.5em}

\preauthor{\begin{flushleft}
					\large \lineskip 0.5em \usefont{OT1}{phv}{b}{sl} \color{DarkRed}}
\author{Avinash Joshi\\}											% Author name goes here
\postauthor{\footnotesize \usefont{OT1}{phv}{m}{sl} \color{DarkRed} 
					Labs -Innovation and Development\\Mu Sigma Business Solutions Pvt Ltd \HorRule  }						% }
%\end{center}

\date{}																				% No date




\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

\begin{abstract}
This paper details the procedure followed in choosing the programming language to be used for writing agents for agent based modelling(referred to as ABM in future). Faster an agent finishes its computations, faster will be its response and hence can be more efficient in this world of real time analytics. Different programming languages are built on different architecture and follow different protocols. Each has its own reasons for being created and has its advantages and disadvantages. The goal of this paper is to find the suitable programming language which will be the most efficient not only considering the computation time but also learning curve, ability to run the code in parallel, interfacing with R and availability of libraries. A list of languages has been made based on some intuition, a set of benchmark tests shall be run on these to decide on the language for building agents.
\end{abstract}
\clearpage

\tableofcontents
\clearpage

\section{Introduction}
\initial{P}rogramming language is an artificial language designed to execute instructions on a machine, particularly a computer. Programming languages can be used to create programs that control the behavior of a machine and/or to express algorithms precisely. Each language has a unique set of keywords (words that it understands) and a special syntax for organizing program instructions. High-level programming languages, while simple compared to human languages, are more complex than the languages the computer actually understands, called machine languages. Each different type of CPU has its own unique machine language.\\
Lying between machine languages and high-level languages are languages called assembly languages. Assembly languages are similar to machine languages, but they are much easier to program in because they allow a programmer to substitute names for numbers. Machine languages consist of numbers only. Regardless of what language you use, you eventually need to convert your program into machine language so that the computer can understand it. There are two ways to do this:

\begin{itemize}
\item Compile the program
\item Interpret the program\\
\end{itemize}

An interpreter translates high-level instructions into an intermediate form, which it then executes. In contrast, a compiler translates high-level instructions directly into machine language. Compiled programs generally run faster than interpreted programs. The advantage of an interpreter, however, is that it does not need to go through the compilation stage during which machine instructions are generated. This process can be time-consuming if the program is long. The interpreter, on the other hand, can immediately execute high-level programs.\\

The question of which language is best is one that consumes a lot of time and energy among computer professionals. Every language has its strengths and weaknesses. For example, FORTRAN is a particularly good language for processing numerical data, but it does not lend itself very well to organizing large programs. Pascal is very good for writing well-structured and readable programs, but it is not as flexible as the C programming language. C++ embodies powerful object-oriented features, but it is complex and difficult to learn.\\

For building agents the major computations involve linear algebra using matrices and optimization. Keeping above things in mind, a set of languages have been decided to be bench marked and tested on. The intuition behind choosing these languages is explained later in the paper. 
\begin{itemize}
\item Julia
\item Incanter/Clojure
\item Python + SciPi
\item Fortran
\item C++/Rcpp
\item Scala
\end{itemize}
\clearpage

\section{Field of study }
Research for finding the best possible language for a specific set of operations. Find the accurate set of tests needed to be run so as to zero in on a language that is not only efficient but also simple enough to learn.

\subsection{Hypothesis/Intuition }
\begin{table}[htp]
\begin{tabular}{|l|l|}
\hline 
Programming Language & Reasons\tabularnewline
\hline 
\hline 
\multirow{1.Julia} &  \textbullet{}Faster than R owing to JIT compiler and better parallel computing\\ 
& \textbullet{}Easier to learn as it is similar to R \\
& \textbullet{}Not much community support and very few libraries\\
& \textbullet{}Easy to interface with C and its libraries\tabularnewline
\hline
\multirow{2.Incanter/Clojure} & \textbullet{}Based on Java\\
&\textbullet{}Faster than R\\
&\textbullet{}Java numerical libraries available\\
&\textbullet{}Should be easy to pick up for anyone worked on java before\\ &\textbullet{}Eclipse can be used as an IDE\tabularnewline
\hline 
\multirow{3.Python + SciPi} & \textbullet{}Faster than R under certain condtions(Memory clearance etc)\\
&\textbullet{}High level language hence easy to pick up \\
&\textbullet{}Has decent set of libraries for numerical computation\\& though not many libraries for stats compared to R\tabularnewline
\hline
\multirow{4.C++/Rcpp} & \textbullet{}Amazing computational speed.\\
&\textbullet{}But requires to learn C++(which will take time)\\
&\textbullet{}Good interface with R\\
&\textbullet{}Good set of libraries\tabularnewline
\hline
\multirow{5.Fortran} & \textbullet{}Should have very good computational speed.\\
&\textbullet{}But requires to learn a low level compiled language(which will take time)\\
&\textbullet{}Good set of libraries\tabularnewline
\hline
\multirow{5.Scala} & \textbullet{}Similar to Incanter and Clojure\\
&\textbullet{}Java based\tabularnewline
\hline
\end{tabular}
\end{table}

\section{Challenger method }
Multiple benchmarking functions are available. Adequate tests have been chosen to measure different aspects of a programming language that would be required to build agents.

\section{Approach to tackle the problem }
A set of tests have been devised which require different aspects of a programming language. These tests shall be run on different languages and the time required shall be tabulated. Also the amount of time required to learn the language shall be kept track of to have a qualitative measure of each language.

\section{Experiment environment }
\subsection{Experiments}
The following tests are being run on a virtual machine on a local system. Following are the specs of the system.
\begin{itemize}
\item OS - Ubuntu 12.04
\item Number of cores - 4
\item RAM - 12 GB
\end{itemize}
\textbf{Benchmark tests run:} Basic matrix operations and optimization. Will help in seeing how effective is each language dealing with matrices. Each test was run 15 times and the average time shall be taken as the measure to avoid anomalies in the execution time.\\
\textbf{Test 1 :} \emph{Creation and deformation. Changing the dimensions to $1250 \times 5000$ (1,000,000 times) of a $2500 \times 2500$ matrix.} \\
\textbf{Test 2 :} \emph{Creating a $2400 \times 2400$ matrix and taking the 1000th power of each element.}\\
\textbf{Test 3 :} \emph{Sort a vector of $7,000,000$ elements in ascending order.}\\
\textbf{Test 4 :} \emph{Creating a $2800 \times 2800$ matrix and calculating the product of the transpose of the matrix with the original matrix.}\\
\textbf{Test 5 :} \emph{Linear regression on a $3000 \times 3000$ matrix.}\\
\textbf{Test 6 :} \emph{Fft over 2,400,000 random values}\\
\textbf{Test 7 :} \emph{Compute eigen values of a $640 \times 640$ matrix.}\\
\textbf{Test 8 :} \emph{Compute determinant of a $2500 \times 2500$ matrix.}\\
\textbf{Test 9 :} \emph{Find the cholesky decomposition of a $3000 \times 3000$ matrix.}\\
\textbf{Test 10 :} \emph{Find the inverse of a $1600 \times 1600$ matrix.}\\
\textbf{Test 11 :} \emph{Generate 3,500,000 numbers of a fibbonaci sequence}\\
\textbf{Test 12 :} \emph{Creating a $3000 \times 3000$ Hibbert matrix.}\\
\textbf{Test 13 :} \emph{Creation of a 500x500 Toeplitz matrix(Test for nested loops)}\\
\textbf{Test 14 :} \emph{Sample 20000 points using Gibbs sampler for a joint distribution of Gamma and Normal.}\\
\textbf{Test 15 :} \emph{Optimization of Rastrigin Function using Simulated Annealing algorithm.}\\

\subsection{Evaluation Criteria}
Following is a table giving ratings to each language on different parameters for qualitative analysis. \textbf{Higher the number, better for the language i.e if the parameter is testing for ease of process then 5 means it is easiest while 0 means it is hardest.}
\begin{table}[htp]
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline 
Evaluation Criteria & Julia & Python & R & Rcpp & Fortran & Scala\tabularnewline
\hline 
Ease of learning & 4 & 4 & 5 & 4 & 3 & 3 \tabularnewline
\hline
Documentation & 4 & 4 & 4 & 4 & 3 & 3 \tabularnewline
\hline
Amount of libraries & 2 & 4 & 5 & 5 & 5 & 4\tabularnewline
\hline
Online support & 3 & 5 & 5 & 3 & 2 & 4\tabularnewline
\hline
Integration with R & 0 & 4 & 5 & 5 & 0 & 2 \tabularnewline
\hline
Available IDE's & 0 & 5 & 5 & 5 & 0 & 5\tabularnewline
\hline
Setting it up on Linux/Windows & 4 & 5 & 4 & 5 & 5 & 3 \tabularnewline
\hline
Integration with Java & FALSE & TRUE & TRUE & TRUE & FALSE & TRUE \tabularnewline
\hline
Type of programming & Scripting & Scripting & Scripting & OOP & Low level functional & OOP/functional \tabularnewline
\hline
Maturity of the language & 1 & 5 & 4 & 4 & 5 & 4\tabularnewline
\hline
Compiled/Interpreted & Interpreted & Interpreted & Interpreted & Compiled & Compiled & Interpreted\tabularnewline
\hline
\end{tabular}
\end{table}
\paragraph{Note:}
Incanter/Clojure was considered for benchmarking the languages but was discontinued after a certain point. The performance was extremely bad in  and for improving it, interfacing with Java would be required. As this language is to be utilized by analysts this language was dropped for the benchmarking excercise.
\clearpage

\section{Outcome of benchmark test on various languages}
Following are the bar graphs of the relative time taken by each language to the fastest language for each test. It means that for each test the language having the fastest time is set to 1 and rest show how much slower they are compared to the fastest one for each test. A table of absolute results i.e actual time taked in seconds for all the languages for each test is added in appendix. A github link to the test scripts used for benchmarking is also given in the appendix.\\
\\
\\
<<echo=false,fig=TRUE,width = 15,height = 15>>=
source("~/ggplot_bench.R")
grid.arrange(TB1,TB2,TB3,TB4,TB5,TB6,main = textGrob("Plots relative to the fastest language for each test",gp=gpar(fontsize = 25,fontface = "bold")),sub = textGrob("x axis is the relative time w.r.t fastest language for that test",gp=gpar(fontsize = 20,fontface = "italic")),nrow=2)
@

<<echo=false,fig=TRUE,width = 15 , height = 15>>=
grid.arrange(TB7,TB8,TB9,TB10,TB11,TB12,main = textGrob("Plots relative to the fastest language for each test",gp=gpar(fontsize = 25,fontface = "bold")),sub = textGrob("x axis is the relative time w.r.t fastest language for that test",gp=gpar(fontsize = 20,fontface = "italic")),nrow=2)
@

<<echo=false,fig=TRUE,width = 15 , height = 10>>=
grid.arrange(TB13,TB14,TB15,main = textGrob("Plots relative to the fastest language for each test",gp=gpar(fontsize = 25,fontface = "bold")),sub = textGrob("x axis is the relative time w.r.t fastest language for that test",gp=gpar(fontsize = 20,fontface = "italic")),nrow=1)
@

\section{Conclusion}
Programming languages are used across various fields in the world and hence there exist so many of them. Each field requires a specific set of tools and therefore each language has its unique stand out point and a reason for being created for that particular field. In this paper, a bunch of different languages were chosen and pitted against each other. A set of tests were designed to check the computational time against each other. Also qualitative measures were kept in mind while choosing a language.
Some inferences from the above graphs are:
\begin{itemize}
\item 1. Different languages perform better in different tests
\item 2. On an average Rcpp comes on top with Julia being close second
\item 3. On an average Scala was relatively the slowest though it is fastest for some tests
\end{itemize}
\clearpage

On qualitative measures R,Rcpp and python perform well. All three have decent set of libraries and IDE's and relatively easy to setup and learn.

Computational time is good for Rcpp and Julia. Julia would have been a good option if not for its lack of libraries and low maturity of the language. \textbf{Hence keeping in mind both the qualitative measure and the computational time, the language recommended to be used along with R for agent based modelling is Rcpp.}

\section{Reference material }
\begin{itemize}
\item http://docs.julialang.org/en/latest/manual/
\item http://www.statalgo.com/2012/04/27/statistics-with-julia-least-squares-regression-with-direct-methods/
\item http://docs.python.org/
\item http://docs.scipy.org/doc/numpy/reference/
\item http://docs.scipy.org/doc/scipy/reference/
\item http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/fortran.html
\item http://www.nsc.liu.se/~boein/f77to90/a5.html
\item http://www.scala-lang.org/docu/files/ScalaTutorial.pdf
\item https://github.com/scalala/Scalala
\item https://github.com/scalanlp/breeze
\end{itemize}

\section{Appendix}
\subsection{Bench Mark results (Actual time in seconds)}
<<echo=false,results=tex>>=
library('xtable')
Final = read.csv("FinalResults.csv")
Final.res = xtable(Final, label="Test Results(in secs)",caption = "Time taken for each test in secs")
print(Final.res,hline.after = -1:nrow(Final.res))
@
\subsection{Link to the test scripts}
https://github.com/Mu-Sigma/labs/tree/labs/trunk/LabsRepo/Labs/code/Avinash/Benchmarking\_Languages\_Project
\end{document}